<p align="center">
  <a href ="#comentário-do-texto">Comentário do texto </a>  • 
  <a href ="#trade-off-na-api">Trade-off </a>  • 
  <a href ="#requisitos">Requisitos </a>  • 
  <a href ="#diagrama-de-classes">Diagrama de classes </a>  •
  <a href ="#casos-de-uso">Casos de uso </a>  •
  <a href ="#desenvolvimento">Desenvolvimento </a>  •
  <a href ="#aplicação">Aplicação </a>

## Comentário do texto
#### "We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth. Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming."
Titus Winters, Software Engineering at Google

<br>

>Ser engenheiro de software condiz com todas as mesmas responsabilidades de um desenvolvedor, incluindo algumas além daquelas previstas. Estes, possuem uma visão mais ampla do que os desenvolvedores, exigido então que esse profissional seja ainda mais organizado e preocupado.
O engenheiro se preocupa em resolver os problemas e minimizar os trade-offs para outras partes do sistema.

<br><br>

## Trade-off na API

>O trade off é a decisão que consiste na escolha de uma opção causando a perda de outra, ou seja, uma delas ficará de lado.
Com base nisso, na API, devemos tomar a melhor decisão para a realização do projeto. Optando pela tecnologia que atende melhor a necessidade do cliente e que mais convém aos desenvolvedores.

<br><br>

## Requisitos
**Sistema de uma floricultura**

<br>

>Requisitos Funcionais:
- Efetuar cadastro dos fornecedores
- Cadastrar os produtos
- Consultar dados cadastrados

<br>

>Requisitos não funcionais:
- Interface simples e intuitiva
- Portabilidade
- Protocolo de segurança
- Controle de uso do sistema

<br>

## Diagrama de classes
![Diagrama de Classe](https://user-images.githubusercontent.com/102360635/202266256-2e26f11a-7679-4d09-8cba-1b7ee2a0e768.png) alt="Image" height="50" width="50">

<br><br>

## Casos de uso
![Caso de Uso](https://user-images.githubusercontent.com/102360635/202266286-5f3469cb-ee0b-4923-808d-f45a2013a912.png)

<br><br>

## Desenvolvimento
>Classe Sistema_Floricultura

<br>

![ClasseSistemaFloricultura](https://user-images.githubusercontent.com/102360635/202268265-00214a44-0de6-4b83-9523-6bacbdfec553.png)

<br>

>Código em Java

<br>

>Classe Fornecedor

<br>

![ClasseFornecedor](https://user-images.githubusercontent.com/102360635/202268286-9cece3a5-9f92-4a2f-9773-f0669148782d.png)

<br>

>Código em Java

<br>

![CodFornecedor](https://user-images.githubusercontent.com/102360635/202273632-d4e7f0f1-1bfd-430e-b463-4af555118b0f.png)

<br>

>Classe Produto

<br>

![ClasseProduto](https://user-images.githubusercontent.com/102360635/202268301-7c31f009-1b3e-4c35-83cf-24fd2cc93266.png)

<br>

>Código em Java

<br>

![CodProduto](https://user-images.githubusercontent.com/102360635/202273597-10262f3d-cff5-43e5-90ea-bc06592fc71b.png)

<br><br>

## Aplicação
https://user-images.githubusercontent.com/102360635/201534261-8f2200e3-6186-4c6e-a1aa-bc1be95ce5f4.mp4
